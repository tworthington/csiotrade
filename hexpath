#! /usr/bin/forth

wordlist: hexpath

forth only
definitions

: openmap
    s" hexmap.blk" blockfile
;

: $delimit
  char parse   ( caddr len)
;

: digression ( <word> <char>file<char> -- )
  bl word find nip
  $delimit     ( flag caddr len)
  rot if  2drop  else included then
;

digression dups "utils"

digression lists "lists"

lists last

digression hexes "hexes"

hexes first

digression mapmaking "mapmaking"
mapmaking first

hexpath first definitions

variable origin
variable destination
variable lowcost

create bestroute  5000 cells allot
create thisroute  5000 cells allot

: todestination ( hex -- distance)
    destination @ hexdis
;

\ is hex1 closer to destination than hex2?
: closer? ( hex1 hex2 -- flag)
    todestination swap todestination 
    >
;

: closest  ( list l -- list l )
    dup 2 < if exit then
    dup >r
    1 do ( list best)
        i pick
        over closer?
        if i roll then
    loop
    r>
;

\ order hexes with closest to destination at top
: descending ( list l -- list2 l2)
    dup if
        closest
        swap
        >r
        1-
        recurse
        1+ r> swap
    then
;



: .best
    origin @ .
    bestroute count  ( cell0 length)
    0 do
        dup i cells+ @ .        
    loop
    drop
;

: .route
    thisroute count  ( cell0 length)
    0 do
        dup i cells+ @ .        
    loop
    drop
;

: countup ( pathcost -- )
    .route
    ." Home  @ Cost: " dup . cr

    dup lowcost @
    u< if       
        lowcost !
        thisroute @ 1+ cells
    
        thisroute bestroute rot move
        ." Taking"
    else
        drop
        ." Rejecting " 
    then
    cr
;

: impossible? ( hex cost -- flag)
    swap destination @ hexdis
    cheapest @ * + ( lowestpossible)
    lowcost @ u>
;
    

: addtopath ( hex --)
    thisroute
    count cells+ !
    1 thisroute +!
\    .route
;

: move£ ( hex1 hex2 -- cost)
    tuck hexhexdir
    opposite enter£
;

: report ( thishex cost)
    thisroute cell+ @ 610 = if
        .route
        ." From " over .
        ." is " over destination @ hexdis dup .
        ." which is at least " cheapest @ * .
        ." on top of " .
        ." rejecting." cr
    else
        drop
    then
    drop
;

\ add the cost of
: search ( costsofar lasthex thishex -- )
\    ." In hex: " dup .  ." from hex: " over .
    dup addtopath
    tuck move£  ( costsofar thishex stepcost)
    rot + ( thishex costsofar)
\    .route cr
\    ." Cost to here: " dup . ." Len: " thisroute @ . cr
    lowcost @ over u< if 2drop  exit then
    2dup impossible? if report exit then
    over destination @ = if  countup drop exit then ( thishex costsofar )
    over 2>r     ( thishex | costsofar thishex)
    neighbours descending ( [neighbours] l | costsofar thishex)
    begin
        ?dup while
            1- swap
            2r@ ( [neighbours] l nextHex costsofar thishex | costsofar thishex)
            rot ( [neighbours] l costsofar thishex nexthex | costsofar thishex)
            recurse  ( [neighbours] l | costsofar thishex)
            -1 thisroute +!
    repeat
    rdrop rdrop
;


: reset ( from to -- )
    destination !
    origin !

    0 bestroute !
    0 thisroute !
    -1 lowcost !
;

\ destination must be set
: route ( from )
    neighbours descending
    times ( [neighbours])
        0 thisroute !
        0 origin @ rot  ( 0 origin nexthex)
        search        
    iterate
;

: hexpath  ( from to -- )
    reset
    origin @
    route
    .best
    ." Cost: " lowcost @ . cr
;

: cost ( from to -- d )
    reset origin @ route
    lowcost @
;

: trade ( from pop1 to pop2 -- m )
    rot ( f t p2 p1 )
    2swap cost 2/ ( p2 p1 d)
    dup>r
    */ r> /
;

openmap

2623 constant csio

\ openmap 1209 911 hexpath
\ openmap 510 1209 hexpath

\ 101 908 area