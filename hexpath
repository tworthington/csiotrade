#! /usr/bin/forth

wordlist: hexpath

forth only
definitions

: openmap
    s" hexmap.blk" blockfile
;

: $delimit
  char parse   ( caddr len)
;

: digression ( <word> <char>file<char> -- )
  bl word find nip
  $delimit     ( flag caddr len)
  rot if  2drop  else included then
;

digression dups "utils"

digression lists "lists"

lists last

digression hexes "hexes"

hexes first

digression mapmaking "mapmaking"
mapmaking first

hexpath first definitions

variable origin
variable destination
variable lowcost

create bestroute  5000 cells allot
create thisroute  5000 cells allot

: todestination ( hex -- distance)
    destination @ hexdis
;

\ is hex1 closer to destination than hex2?
: closer? ( hex1 hex2 -- flag)
    todestination swap todestination 
    >
;

: closest  ( list l -- list l )
    dup 2 < if exit then
    dup >r
    1 do ( list best)
        i pick
        over closer?
        if i roll then
    loop
    r>
;

\ order hexes with closest to destination at top
: descending ( list l -- list2 l2)
    dup if
        closest
        swap
        >r
        1-
        recurse
        1+ r> swap
    then
;

: .best
    bestroute count  ( cell0 length)
    0 do
        dup i cells+ @ .        
    loop
    drop
;

: .route
    thisroute count  ( cell0 length)
    0 do
        dup i cells+ @ .        
    loop
    drop
;

: countup ( pathcost -- )
\    .route
\    ." Home  @ Cost: " dup . cr

    dup lowcost @
    u< if       
        lowcost !
        thisroute @ 1+ cells
    
        thisroute bestroute rot move
        .best
        ." @ Cost: " lowcost @ .
        ." Taking"
\        key drop
        cr
    else
        drop
\        ." Rejecting " 
    then
;

: impossible? ( hex cost -- flag)
    swap destination @ hexdis
    cheapest @ * + ( lowestpossible)
    lowcost @ u>
;
    

: addtopath ( hex --)
    thisroute
    count cells+ !
    1 thisroute +!
\    .route
;


: report ( thishex cost --)
    thisroute cell+ @ 0 = if
        .route
        ." From " over .
        ." is " over destination @ hexdis dup .
        ." which is at least " cheapest @ * .
        ." on top of " .
        ." rejecting." cr
    else
        drop
    then
    drop
;

: repeat? ( hex -- flag)
    thisroute count ( hex addr count)
    1-
    cells over + swap
    do ( hex)
\        ." repeat? " i  @ . cr
        dup i @ = if drop unloop -1 exit then
    [ 1 cells ] literal +loop
    drop 0
;

: cache ( hex costtohex -- )
    lowcost @ diff  ( hex costfromhere)
    swap
    >hex >cache ! update
;

: cache@ ( hex -- costtodestination)
    >hex >cache @
;

: (-cache) ( hex# -- )
    >hex >cache 0 swap ! update
;

: -cache
    101 lasthex area times (-cache) iterate
    flush
;

: cachekill? ( thishex costsofar -- flag)
    swap  cache@ ( costsofar todest)
    dup if
        + ( totalcosttodest)
        lowcost @ u>
    else
        and
    then
;   

\ add the cost of this hex and search the neighbours
: search ( costsofar lasthex thishex -- )
\    ." In hex: " dup .  ." from hex: " over . cr
\    .s cr
    dup addtopath
    tuck moveÂ£  ( costsofar thishex stepcost)
    rot + ( thishex costsofar)
\    ." In hex: " over . 
    over destination @ = if  countup drop exit then ( thishex costsofar )
    lowcost @ over u< if 2drop  exit then
    2dup impossible? if 2drop exit then
    2dup cachekill? if 2drop exit then
    over repeat? if 2drop exit then
\    .s depth . cr depth 1- pick 6000 > if bye then
    over 2>r     ( thishex | costsofar thishex)
    neighbours descending ( [neighbours] l | costsofar thishex)
    begin
        ?dup while
            1- swap
            2r@ ( [neighbours] l nextHex costsofar thishex | costsofar thishex)
            rot ( [neighbours] l costsofar thishex nexthex | costsofar thishex)
            recurse  ( [neighbours] l | costsofar thishex)
            -1 thisroute +!
    repeat
\    2r> 2drop
     r> r> cache
;


: reset ( from to -- )
    destination !
    origin !

    -cache
    
    0 bestroute !
    0 thisroute !
    -1 lowcost !
;

\ destination must be set
: route ( from )
    neighbours descending
    times ( [neighbours])
        1 thisroute !
        origin @ thisroute cell+ !
        0 origin @ rot  ( 0 origin nexthex)
        search        
    iterate
;

2variable startns
2variable endns

: allocate ( size -- addr)
    >r
    0 -1 2 32 r> 0 6 192 linux
    dup 0 > if -999 throw then
;



: hexpath  ( from to -- )
    ns startns 2!
    reset
    origin @
    route
    ns endns 2!
    .best
    ." Cost: " lowcost @ . cr
    startns 2@
    endns 2@
    ." Time: "  ns- .ns
;

: rcost ( from to -- d )
    reset origin @ route
    lowcost @
;

: (trade) ( pop1 pop2 pathdist) dup 100 */ ?dup if */ else 2drop 0 then ;

: trade ( from pop1 to pop2 -- m )
    rot ( f t p2 p1 )
    2swap rcost ( p2 p1 distance)
    (trade)
;
    

\ openmap

4829 constant ossary  \ 3200
2623 constant csio    \ 20000

: t ossary csio hexpath ;



\ openmap 1209 911 hexpath
\ openmap 510 1209 hexpath

\ 101 908 area