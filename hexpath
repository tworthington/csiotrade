#! /usr/bin/forth

wordlist: hexpath

forth only
definitions

: openmap
    s" hexmap.blk" blockfile
;

: $delimit
  char parse   ( caddr len)
;

: digression ( <word> <char>file<char> -- )
  bl word find nip
  $delimit     ( flag caddr len)
  rot if  2drop  else included then
;

digression dups "utils"

digression lists "lists"

lists last

digression hexes "hexes"

hexes first

digression mapmaking "mapmaking"
mapmaking first

hexpath first definitions

variable origin
variable destination
variable lowcost

create bestroute  5000 cells allot
create thisroute  5000 cells allot

: todestination ( hex -- distance)
    destination @ hexdis
;

\ is hex1 closer to destination than hex2?
: closer? ( hex1 hex2 -- flag)
    todestination swap todestination 
    >
;

: closest  ( list l -- list l )
    dup 2 < if exit then
    dup >r
    1 do ( list best)
        i pick
        over closer?
        if i roll then
    loop
    r>
;

\ order hexes with closest to destination at top
: descending ( list l -- list2 l2)
    dup if
        closest
        swap
        >r
        1-
        recurse
        1+ r> swap
    then
;


: terrain! ( terrain hex )
    ! update
;

\ a must be ≤ b
: between? ( n a b -- flag)
    -rot ( b n a )
    over > not ( b n f1)
    -rot
    < not and
;

\ unsigned version
: ubetween? ( n a b -- flag)
    -rot ( b n a )
    over u> not ( b n f1)
    -rot
    u< not and
;
    

: row ( hex -- y)
    100 mod ;

: col 100 / ;

: col? ( x y -- flag )
    drop
    1 52 between?
;

: oddcol? ( hex# -- flag)
    100 / odd? ;

: row? ( x y -- flag)
    swap odd? if
        100 mod 1 34 between?
    else
        100 mod 1 33 between?
    then
;

\ Hex to north
\ Return 0 for hexes off map
: hex>n ( hex -- hex2)
    1- dup row 0<> and   \ faster than row?
;

\ hex to south
: hex>s
    1+
    dup hex#>xy
    row? and
;

: test+convert ( x y -- hex#)
    2dup row? -if 2drop 0. else
        2dup col? -if 2drop 0. then then
    xy>hex#
;

\ hex to ne
: hex>ne
    hex#>xy
    over odd? + ( x y2)
    swap 1+ swap    ( x2 y2)
    test+convert
;

: hex>se
    hex#>xy
    over odd? not negate +
    swap 1+ swap
    test+convert
;

: hex>s
    1+
    dup dup oddcol? -
    100 mod 34 < and
;

: hex>sw
    hex#>xy
    over odd? not negate + 
    swap 1- swap test+convert
;

: hex>nw
    hex#>xy
    over odd? +
    swap 1- swap test+convert
;

: hex>w
    100 - dup 99 > and ;

\ bias north on bottom row
: hex>e
    dup 100 mod 34 =  \ flag=0 or -1
    100 + +
    dup 5300 < and ;

create steptab
' hex>n , ' hex>ne , ' hex>se ,
' hex>s , ' hex>sw , ' hex>nw ,
' hex>w , ' hex>e ,

: dir>hex ( hex dir -- hex2)
    dup>r
    r@    -if  hex>n   rdrop exit then
    r@ 1 = if  hex>ne  rdrop exit then
    r@ 2 = if  hex>se  rdrop exit then
    r@ 3 = if  hex>s   rdrop exit then
    r@ 4 = if  hex>sw  rdrop exit then
    r@ 5 = if  hex>nw  rdrop exit then
    rdrop 1 throw
;

: ?l+ ?dup if l+ then ;

: neighbours ( hex# -- hex#1 hex#2...hexnn n)
    >r 
    list
    r@ hex>nw ?l+
    r@ hex>sw ?l+
    r@ hex>s  ?l+
    r@ hex>se ?l+
    r@ hex>ne ?l+
    r@ hex>n  ?l+
    rdrop
;

: incoming! ( hexes l cost1 hex# -- )   \ 0 1  2  3 4  5
    rot times ( hexn cost1 hex# )       \ n ne se s sw nw
        rot ?dup if  ( cost1 hex# hexn )
            >hex @ cost  ( cost1 hex# cost2)
            rot tuck + 2/   ( hex# cost1 costIn)
            2 pick >hex i 1+ cells+ ! update
            swap ( cost1 hex#)
        else ( cost1 hex#)
            0 over >hex i 1+ cells+ ! update
        then
    iterate
    2drop
;

\ average cost with my own cost
: dir! ( hex# cost1 FromDirection -- )
    rot ?dup if ( cost1 from hex#)
        >hex dup @ cost  ( cost1 from hex^ cost2 )
\        .s cr
        -rot ( c1 c2 from hex)
        swap 1+ cells+ ( c1 c2 c^^ )
        -rot + 2/ swap ! update
    else
        2drop
    then
;

\ entering this hex from this face carries
\ a different cost.
: side!  ( hex# cost1 direction -- )
    1+ cells rot >hex + ! update
;

: hexhexdir ( hex1 hex2 --- dir)
    >r
    neighbours drop
    r@ = if rdrop 5 drops 0  exit then
    r@ = if rdrop 4 drops 1 exit then
    r@ = if rdrop 3 drops 2 exit then
    r@ = if rdrop 2drop   3 exit then
    r@ = if rdrop drop    4 exit then
    r@ = if rdrop         5 exit then
    rdrop 2 throw
;

: (connect) ( cost dir1 hex1 hex2 )
    >r rot dup>r  ( d1 h1 cost | h2 cost)
    rot dup opposite >r  ( h1 cost dir1 | h2 cost dir2)
    side!
    r> r> r> -rot swap side! update
;
    

: connect ( cost hex1# hex2 -- ) ( h c d h2 )
    2dup hexhexdir  ( cost hex1 hex2 dir)
    -rot      
    (connect)
;

: path ( hexlist l cost -- )
    swap ?dup if
        1- times ( hexn-1 hexn cost)
            >r 2dup r@ -rot  ( hn-1 hn cost hn-1 hn  |cost)
            connect drop ( hn-1 |cost)
            r> ( hn-1 cost)
        iterate
    then
    2drop
;


: outgoing! ( hexes l cost1 -- )
\    .s cr
    swap 0 do  ( hexn cost1 )  \ i is direction from 0
        tuck i opposite dir!
    loop
    drop  \ cost1
;

\ Set the given hex
\ Set the entry cost from this hex
\ to each adjacent hex
\ set the entry cost from each adjacent hex
\ to this hex
: (setland)
    2dup >hex terrain!
    swap cost  ( hex# cost )
    over 2>r ( hex# |cost hex#)
    neighbours 2r@ incoming!
    r> neighbours \ .s cr
    r> outgoing!
;

: (setsea)
;

: sethex ( terrain hex# -- )
    2dup >hex terrain!
    swap cost  ( hex# cost )
    over 2>r ( hex# |cost hex#)
    neighbours 2r@ incoming!
    r> neighbours \ .s cr
    r> outgoing!
;

: paint ( [hexs] l terrain -- )
    swap times ( [hexes] tophex terrain)
        tuck swap sethex
    iterate
    drop
;

: (area) ( n brx tlx x - hex1 hex2... hexn n)
    -rot
    2dup 2>r
    1 under+
    do ( n x |r brx tlx)
        dup i ( n x x y)
        swap xy>hex# ( n x hex)
        rot 1+ ( x hex n2)
        rot ( hex n2 x)
    loop
    drop
    2r>
;

: area ( tl br -- hex1 hex2 ... hexn n )
    0 -rot ( n tl br )
    hex#>xy rot  ( n brx bry tl )
    hex#>xy      ( n brx bry tlx tly)
    rot swap ( n brx tlx bry tly)
    1 under+
    do  ( n brx tlx)
        i (area)
    loop
    2drop
;

\ 908 from
\ se 10 steps

: from ( hex# -- hex# 1) 1 ;


: steps ( list ln dir x -- list2 ln+x)
    rot >r ( list dir x )
    dup>r
    times ( hexes dir)
        2dup cells steptab +  ( hex dir hex xt^)
        @ execute ( hex dir hex2|0)
        dup 0= if 4 throw then
        swap
    iterate  ( hexes dir | ln x)
    drop
    2r> +
;


: .best
    origin @ .
    bestroute count  ( cell0 length)
    0 do
        dup i cells+ @ .        
    loop
    drop
;

: .route
    thisroute count  ( cell0 length)
    0 do
        dup i cells+ @ .        
    loop
    drop
;

: countup ( pathcost -- )
    .route
    ." Home  @ Cost: " dup . cr

    dup lowcost @
    u< if       
        lowcost !
        thisroute @ 1+ cells
    
        thisroute bestroute rot move
        ." Taking"
    else
        drop
        ." Rejecting " 
    then
    cr
;

: impossible? ( hex cost -- flag)
    swap destination @ hexdis
    cheapest @ * + ( lowestpossible)
    lowcost @ u>
;
    

: addtopath ( hex --)
    thisroute
    count cells+ !
    1 thisroute +!
\    .route
;

: move£ ( hex1 hex2 -- cost)
    tuck hexhexdir
    opposite enter£
;

: report ( thishex cost)
    thisroute cell+ @ 610 = if
        .route
        ." From " over .
        ." is " over destination @ hexdis dup .
        ." which is at least " cheapest @ * .
        ." on top of " .
        ." rejecting." cr
    else
        drop
    then
    drop
;

\ add the cost of
: search ( costsofar lasthex thishex -- )
\    ." In hex: " dup .  ." from hex: " over .
    dup addtopath
    tuck move£  ( costsofar thishex stepcost)
    rot + ( thishex costsofar)
\    .route cr
\    ." Cost to here: " dup . ." Len: " thisroute @ . cr
    lowcost @ over u< if 2drop  exit then
    2dup impossible? if report exit then
    over destination @ = if  countup drop exit then ( thishex costsofar )
    over 2>r     ( thishex | costsofar thishex)
    neighbours descending ( [neighbours] l | costsofar thishex)
    begin
        ?dup while
            1- swap
            2r@ ( [neighbours] l nextHex costsofar thishex | costsofar thishex)
            rot ( [neighbours] l costsofar thishex nexthex | costsofar thishex)
            recurse  ( [neighbours] l | costsofar thishex)
            -1 thisroute +!
    repeat
    rdrop rdrop
;



: hexpath  ( from to -- )
    destination !
    origin !
    0 bestroute !
    0 thisroute !
    -1 lowcost !

    origin @
    neighbours descending
    times ( [neighbours])
        0 thisroute !
        0 origin @ rot  ( 0 origin nexthex)
        search        
    iterate
    cr
    .best
    ." Cost: " lowcost @ . cr
;

openmap

2623 constant csio

\ openmap 1209 911 hexpath
\ openmap 510 1209 hexpath

\ 101 908 area