#! /usr/bin/forth

wordlist: routeapp

forth only
definitions

: openmap
    s" hexmap.blk" blockfile
;

requires utils

digression lists "lists"

lists last

requires squares
squares first

digression mapmaking "bmpread"
mapmaking first

routeapp first definitions

variable origin
variable destination
variable lowcost

create thisroute  50000 cells allot
create routecost  50000 cells allot

sqrts @ 4 / +vector: atleasts
sqrts @ 4 / +vector: bestmove

atleasts count 0 fill

[[ vectors

mapsquares +vector: sqcache

: -cache
    sqcache count 0 fill
;

-cache

: cache! ( sq costtosq -- )
  dup infinite u< -if 2drop else
  sqcache rot v! then ;

: cache@ ( sq -- costtodestination)
    sqcache swap v@
;

: updates ( from cost to -- cost )
    >r 2dup cache!
    swap r> ( cost from to)
    bestmove rot v!
;

]]


: todestination ( sq -- distance)
    destination @ sqdist
;

: qdist ( x1 y1 x2 y2 -- distance-squared)
    rot - dup * ( x1 x2 dy²)
    -rot - dup *
    +
;

\ is sq1 closer to destination than sq2?
: closer? ( sq1 sq2 -- flag)
    >xy rot >xy ( x2 y2 x1 y1)
    destination @ >xy 2dup 2>r
    qdist ( x2 y2 d1²)
    -rot 2r> qdist ( d1² d2²)
    <
;

: cheaper? ( sq1 sq2 --flag)
    sqcache swap v@ sqcache rot v@ >
;

: cheapest  ( list l -- list l )
    dup 2 < if exit then
    dup >r
    1 do ( list best)
        i pick
        over cheaper?
        if i roll then
    loop
    r>
;

: closest  ( list l -- list l )
    dup 2 < if exit then
    dup >r
    1 do ( list best)
        i pick
        over closer?
        if i roll then
    loop
    r>
;

\ order hexes with closest to destination at top
: descending ( list l -- list2 l2)
    dup if
        closest
        swap
        >r
        1-
        recurse
        1+ r> swap
    then
;

: .route
    thisroute count  ( cell0 length)
    0 do
        dup i cells+ @ .xy        
    loop
    drop
;

: pathcost ( -- costOfPath)
    routecost thisroute @ cells+ @
;

: overrun? ( -- flag) pathcost lowcost @ u> ;

: addsq ( sq -- )
    thisroute
    count cells+ !
    1 thisroute +!
;    

\ thisroute and routecost share length
\ Add this cost to previous cost
\ cost_0 is alway 0
: addcost ( cost )
    routecost
    thisroute @ 
    cells+  ( cost addr1)
    @+ ( cost oldcost addr2)
    >r +
    r> !
;

: addtopath ( from to -- )
    tuck move£
    addcost  ( to)
    addsq 
;


: report ( --)
    .route
    key drop
;

: repeat? ( sq -- flag)
    thisroute count ( sq addr count)
    ?dup if
        1-
        cells over + swap
        do ( sq)
\        ." repeat? " i  @ . cr
          dup i @ = if drop unloop -1 exit then
          [ 1 cells ] literal +loop
    then
    drop 0
;

: countup ( cachedvalue -- cachedvalue )
  cr
  ." Cost: " pathcost .
  ." ( " thisroute  @ . ." steps ) "
  .route cr

  pathcost
  lowcost @
  u< if
    pathcost lowcost !

    ." Taking"
    \ key drop
\        key 27 = if abort" Break" then
  else
    ." Rejecting "
  then
  [char] . emit
;


\ Find cost of best move from here.
\ Cost=cost to nextSq+cost from nextSq

: search ( previoussq thissq -- costFromHere)
    \    key drop
    tuck
    addtopath ( thissq)
    dup repeat? if  drop infinite exit then
    dup destination @ = if drop 0 countup exit then ( thissq  )
    dup cache@ ?dup if nip countup exit then
    overrun? if drop infinite exit then
    dup>r infinite >r     ( thissq | thissq best)
    neighbours descending ( [neighbours] l | thissq  best )
    \ find new best
    begin
        ?dup while
            1- swap  ( [neighbours] l-1 nextsq | thissq best )
            dup 2r@ drop move£ ( nxsq costtonx | thissq best )
            over 2r@ drop swap ( nxsq costtonx thissq nxsq)
            recurse  ( [neighbours] l nxsq costtonext costfromNext| thissq best )
            -1 thisroute +!
            +
            r@   ( nx fromHere best | thissq best)
            2dup u< -if 2drop drop
            else
                drop rdrop   ( nx newBest | thissq)
                swap bestmove r@ v!
                >r             ( | thissq best)
            then
    repeat           ( |r: thissq best )
\ Looked at all neighbours now
2r> tuck cache!
\    [char] x emit depth .
;


: reset ( to from -- )
    origin !
    destination !
    
    0 routecost !
    0 thisroute !
    -1 lowcost !
;

2variable startns
2variable endns

: pixelpath  ( to from -- )
    cr ." Starting from " dup .xy ." ( " dup sq@ . ." )" cr
    ." Going to      " over .xy ." ( " over sq@ . ." ) " cr
    reset
    origin @ dup search countup .
;

\ optimise later
: validedges? ( dest disp -- dest disp flag)
    >r
    dup >xy ( dest x y |r: disp)
    dup r@ - 0< -if  2drop r> -1 exit then   \ North edge valid
    r@ + height < if drop r> -1 exit       then   \ South edge valid
    ( dest x|r: disp)
    dup r@ - 0< -if  drop r> -1 exit then    \ West edge valid
    r@ + width < if  r> -1 exit      then    \ East edge valid
    r> 0  \ no valid edges
;

: donorth ( dest displacement -- )
    ." North" cr
    >r
    dup >xy ( dest x y |r: disp)
    r@ - dup 0< if \ off north side of map
        rdrop 2drop drop
    else ( dest x y2 |r: disp)
        swap   ( dest y2 x |r: disp)
        dup r@ + width 1- min 1+ ( dest y2 x xne|r: disp) \ 1+ for do..loop
        swap r> - 0 max   ( dest y2 xne xnw)
        do ( dest y2)         \ i will be x2
            2dup i swap xy>sq ( dest y2 dest origin)
            pixelpath
        loop
        2drop
    then
;

: dosouth ( dest displacement -- )
    ." South" cr
    >r
    dup >xy ( dest x y |r: disp)
    r@ + dup height < -if \ off south side of map
        rdrop 2drop drop
    else ( dest x y2 |r: disp)
        swap   ( dest y2 x |r: disp)
        dup r@ + width 1- min 1+ ( dest y2 x xne|r: disp) \ 1+ for do..loop
        swap r> - 0 max   ( dest y2 xne xnw)
        do ( dest y2)         \ i will be x2
            2dup i swap xy>sq ( dest y2 dest origin)
            pixelpath
        loop
        2drop
    then
;

: dowest ( dest displacement -- )
    ." West" cr
    >r
    dup >xy ( dest x y |r: disp)
    swap r@ - tuck 0< if \ off west side of map
        rdrop 2drop drop
    else ( dest x2 y |r: disp)
        dup r@ + height 1- min 1+ ( dest x2 y ysw|r: disp) \ 1+ for do..loop
        swap r> - 0 max   ( dest x2 ysw ynw)
        do ( dest x2)    \ i will be y2
            2dup i xy>sq ( dest x2 dest origin)
            pixelpath
        loop
        2drop
    then
;


: doeast ( dest displacement -- )
    ." East" cr
    >r
    dup >xy ( dest x y |r: disp)
    swap r@ + tuck width < -if \ off east side of map
        rdrop 2drop drop
    else ( dest x2 y |r: disp)
        dup r@ + height 1- min 1+ ( dest x2 y ysw|r: disp) \ 1+ for do..loop
        swap r> - 0 max   ( dest x2 ysw ynw)
        do ( dest x2)    \ i will be y2
            2dup i xy>sq ( dest x2 dest origin)
            pixelpath
        loop
        2drop
    then
;


: (fillcache) ( dest)
    -cache  \ make sure it's empty first
    0 ( dest disp)
    begin
        1+         cr ." Displacement " dup . cr
        validedges?
    while ( dest disp)
            2>r 
            2r@ donorth
            2r@ doeast
            2r@ dosouth
            2r@ dowest
            2r>
    repeat
    2drop
;
    
: fillcache ( dest )
    ns startns 2!
    ['] (fillcache) literal
    1000000 bigrs
    ns endns 2!
    startns 2@
    endns 2@
    ." Time: "  ns- .ns

;


: (trade) ( pop1 pop2 pathdist) dup 100 */ ?dup if */ else 2drop 0 then ;

: trade ( from pop1 to pop2 -- m )
    rot ( f t p2 p1 )
    2swap rcost ( p2 p1 distance)
    (trade)
;
    

: t 21 32 xy>sq 56 37 xy>sq pixelpath ;
: t 56 37 xy>sq 54 5  xy>sq pixelpath ;
: t 21 32 xy>sq dup destination ! fillcache ;

: .from xy>sq cache@ . ;
: best? bestmove swap v@ dup .xy ;

: traceroute ( x y -- )
  xy>sq
  begin
    best? ?dup while repeat
;


\ openmap

4829 constant ossary  \ 3200
2623 constant csio    \ 20000

\ : t ossary csio pixelpath ;

\ ' t 1000000 bigrs

-cache

: t ['] t literal 1000000 bigrs ;

\ openmap 1209 911 pixelpath
\ openmap 510 1209 pixelpath

\ 101 908 area

: .map
  height times
  width times
  j i xy@ .
  iterate cr iterate ;
