#! /usr/bin/forth

wordlist: routeapp

forth only
definitions

requires utils
order
digression params "params"

digression lists "lists"

\ lists last
order
digression pqueues "pqueue"

\ pqueues last
order
digression mapmaking "bmpread"
\ mapmaking first

order
requires squares
squares first

digression city: "cities"

routeapp first definitions

variable destination
variable origin

\ Worst case scenario: all squares have 8 possible approaches
mapsquares cells 8 * pqueue: frontier
mapsquares +vector: camefrom
mapsquares +vector: costsofar

mapsquares +vector: tradevol

: .frontier
  frontier size times
  i frontier priority# .
  i frontier item# .xy cr
  iterate
;

sqrts @ 4 / +vector: bestmove

: qdist ( x1 y1 x2 y2 -- distance-squared)
    rot - dup * ( x1 x2 dy²)
    -rot - dup *
    + 2sqrt
;

: todestination ( sq -- distance)
    >xy 
    destination @ >xy qdist
;


: qdist
    rot - dup * ( x1 x2 dy²)
    -rot - dup *
    +
;

\ is sq1 closer to destination than sq2?
: closer? ( sq1 sq2 -- flag)
    >xy rot >xy ( x2 y2 x1 y1)
    destination @ >xy 2dup 2>r
    qdist ( x2 y2 d1²)
    -rot 2r> qdist ( d1² d2²)
    <
;

: closest  ( list l -- list l )
    dup 2 < if exit then
    dup >r \ for returning proper list
    1 do ( list best)
        i pick
        over closer?
        if i roll then
    loop
    r>
;

\ order squares with closest to destination at top
: descending ( list l -- list2 l)
    dup if
        closest
        swap
        >r
        1-
        recurse
        1+ r> swap
    then
;

: best? ( sq1 -- sq2)
  camefrom swap v@
;

: .from xy>sq best? dup .xy >xy ;

: cost ( sq -- cost ) costsofar swap v@ ;

: traceroute ( x y -- )
  xy>sq ." Cost: " costsofar over v@ .
  dup .xy
  begin
    camefrom swap v@
    dup .xy
    dup destination @ =
  until
  drop
;

: heuristic ( next -- penalty)
  >xy destination @ >xy ( x1 y1 x2 y2)
  rot - abs ( x2 x1 dy)
    -rot - abs ( dy dx)
  dup * swap dup * +
  2sqrt 10 2 */
;

: heuristic 0 and ;

: update ( from next cost)
  2dup costsofar rot v!
  2dup ( from next cost next cost)
  over heuristic +
  frontier -val
  drop
  camefrom swap v!
;

[[ pqueues
\ destination is global
\ cost via square is:
\ thissq=destination -> cost to move
\ else -> cost to move to neighbour with lowest cost
: search1 (  -- )
  begin
    frontier empty? not while
      frontier pop drop ( current)
      origin @ over = if drop exit then
      dup>r neighbours descending  ( list l |  current)
      begin
        ?dup
      while
          1-
          swap   ( list-1 l-1 sq_l |current)
          r@ over move£  ( list l next cost | current)
          costsofar r@ v@ +  ( list l next tcost | current)
          over costsofar swap v@  ( list l next tcost csf)
          dup 0=  >r ( list l next tcost csf  |current flg)
          over
          u> r> or if
            r@  ( list l next tcost current)
            -rot
            update
          else
            2drop
          then
      repeat
      rdrop
  repeat
;

: searchAll (  -- )
  begin
    frontier empty? not while
      frontier pop drop ( current)
      dup>r neighbours descending  ( list l |  current)
      begin
        ?dup
      while
          1-
          swap   ( list-1 l-1 sq_l |current)
          r@ over move£  ( list l next cost | current)
          costsofar r@ v@ +  ( list l next tcost | current)
          over costsofar swap v@  ( list l next tcost csf)
          dup 0=  >r ( list l next tcost csf  |current flg)
          over
          u> r> or if
            r@  ( list l next tcost current)
            -rot
            update
          else
            2drop
          then
      repeat
      rdrop
  repeat
;

]]

: reset ( from to -- )
  [[ pqueues
  frontier clear ]]
  destination !
  origin !  
  destination @ 0 frontier -val
  [[ vectors
  camefrom clear
  costsofar clear ]]
;

2variable startns
2variable endns

: pixelpath1  ( from to -- )
  ns startns 2!
  reset
  search1
  ns endns 2!
  startns 2@
  endns 2@
  ." Time: "  ns- .ns cr
;

: pixelpathAll  ( to -- )
  ns startns 2!
  0 swap reset
  searchAll
  ns endns 2!
  startns 2@
  endns 2@
  ." Time: "  ns- .ns cr
;

: (trade) ( pop1 pop2 pathdist)
  >r 4 mapscale */
  r> */ ;

[[ cities
: modifiers ( trade city1 city2 -- trade2)
  2dup 2>r
  >alignment @ swap
  >alignment @  aligntrade
  2r>
  >civ @ swap
  >civ @  techtrade
;
]]
  
: trade (  pop1 pop2 fromsq -- m )
  cost ( p1 p2 distance)
  (trade)
;

\ Assumes pixelpathAll has been called for setup
: traderoute ( cityFrom cityTo -- vol )
  2dup 2>r
  >pop @ swap ( pop1 from)
  dup >pop @ swap >sq @ ( pop1 pop2 fromsq |r: cityFrom cityTo)
  trade  ( vol |r: cityFrom cityTo)
  r> r@ modifiers  ( vol2 |r: cityFrom)
  r> >sq @
  over dup . cr if
    swap >r
    begin ( vol from)
      tradevol over r@ -rot >vi +!
      camefrom swap v@  ( sq | vol)
      dup destination @ =
    until
    tradevol swap r@ -rot >vi +!
    r>
  else
    2drop
    0
  then
;

cityfile 2@ included

\ trade from city
: citytrade ;

: tradereport
  0 ( tot)
  #cities times
    i thcity >name count type ."  Trade: " tab
    i thcity >trade @ 
    dup . ." (" dup i thcity >pop @ / . ."  per person)" tab ." via: "
    tradevol i thcity >sq @ v@ dup . ." ("  i thcity >pop @ / . ."  per person)"
    cr
    + 
  iterate ." Total trade: " .
;

: alltrade
  #cities times
    i if
      i thcity >sq @ pixelpathAll
      i times
        i j <> if
          ." From " i thcity dup >name count type tab
          ." to " j thcity dup >name count type tab
          traderoute dup i thcity >trade +! j thcity >trade +!
        then
      iterate
    then
  iterate
;

: t alltrade ;

: .trade xy>sq tradevol swap v@ . ;

: .map
  height 0 do
      width 0 do
          i j xy@ . 
      loop
      cr
  loop
;

variable scale


: calibrate ( vector -- )
  [[ vectors    
  maximum 2sqrt
  scale !
  ]]
;

: open> ( caddr len -- handle)
  2dup type cr
  drop 438 swap 2 8 linux
  dup 0= throw
;
  
: process ( vector -- )
    mapsquares 0 do
      dup i v@ dup if  2sqrt 255 scale @ */ 1 max
      then emit
    loop
    drop
;

: header
    ." P5 "
    width . height . 255 .
;

: startfile ( handle --)
    15 user !
    header
;

: output ( handle vector -- )
    swap
    startfile
    process
;

: close
    15 user @
    1 6 linux throw 
    1 15 user ! ;

: trademap
    alltrade
    tradevol calibrate
    tradepgm 2@ open>
    tradevol output
    close
;

: domain ( scale -- )
  mapsquares 0 do
    costsofar i v@ dup if
      over / 
      255 swap - 1 max
    then
    emit
  loop
  drop
;

: days ( -- )
  mapsquares 0 do
    255
      costsofar i v@
      1day / 1+
    /
    emit
  loop
;

: daysmap ( city )
    >sq @ pixelpathAll
    dayspgm 2@ open>
    startfile
    days
    close
;

: domainmap ( city )
  dup
  >sq @ pixelpathAll
  domainpgm 2@ open>
  startfile
  >pop @ 2sqrt 1 max domain
  close
;

: t csio daysmap ;