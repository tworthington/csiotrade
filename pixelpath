#! /usr/bin/forth

wordlist: routeapp

forth only
definitions

: openmap
    s" hexmap.blk" blockfile
;

requires utils

digression lists "lists"

lists last

requires squares
squares first

digression mapmaking "bmpread"
mapmaking first

routeapp first definitions

variable origin
variable destination
variable lowcost

create thisroute  50000 cells allot
create routecost  50000 cells allot
create routeflags 50000 cells allot


sqrts @ 4 / +vector: bestmove

[[ vectors

mapsquares +vector: sqcache

: -cache
    sqcache count  0 fill
;

-cache

: cache@ ( sq -- costtodestination)
    sqcache swap v@
;

: cache! ( sq costtosq -- )
        sqcache rot v!
;


: updates ( from cost to -- cost )
    >r 2dup cache!
    swap r> ( cost from to)
    bestmove rot v!
;

]]


: qdist ( x1 y1 x2 y2 -- distance-squared)
    rot - dup * ( x1 x2 dy²)
    -rot - dup *
    +
;

: todestination ( sq -- distance)
    >xy 
    destination @ >xy qdist
;

: (priority) ( to from -- pri)
    over move£
    swap todestination *
;


\ is sq1 closer to destination than sq2?
: closer? ( sq1 sq2 -- flag)
    >xy rot >xy ( x2 y2 x1 y1)
    destination @ >xy 2dup 2>r
    qdist ( x2 y2 d1²)
    -rot 2r> qdist ( d1² d2²)
    <
;


\ is sq1 better than sq2?
: lower? ( sq1 sq2 origin -- flag)
    tuck ( sq1 origin sq2 origin )
    (priority) -rot (priority)  ( p2 p1)
    >
;
    

: closest  ( list l -- list l )
    dup 2 < if exit then
    dup >r \ for returning proper list
    1 do ( list best)
        i pick
        over closer?
        if i roll then
    loop
    r>
;

: lowest ( list l origin -- list2 l)
    over 2 < if drop exit then
    over >r  \ for returning proper list
    >r \ origin
    1 do
        i pick over r@ lower?
        if i roll then
    loop
    rdrop r>
;

\ order squares with closest to destination at top
: descending ( list l -- list2 l)
    dup if
        closest
        swap
        >r
        1-
        recurse
        1+ r> swap
    then
;

\ Order by ascending distance*cost
: priority ( list l origin -- list2 l2)
    >r
    dup if
        r@
        lowest
        swap
        >r
        1-
        r@ recurse
        1+ r> swap
    then
    rdrop
;


: .route
    thisroute count  ( cell0 length)
    0 do
        dup i cells+ @ .xy        
    loop
    drop
;

: pathcost ( -- costOfPath)
    thisroute @ dup if cells
    routecost + @ then
;

: recflag ( flag -- )
    routeflags thisroute @ cells+
    dup @ rot or swap ! ;

: flag@
    routeflags thisroute @ cells+ @ ;

: flag@ -1 ;

: -flag
    0     routeflags thisroute @ cells+ ! ;

: overrun? ( -- flag) pathcost lowcost @ u> ;

: addsq ( sq -- )
    thisroute
    count cells+ !
    1 thisroute +!
;    

\ thisroute and routecost share length
\ Add this cost to previous cost
\ cost_0 is alway 0
: addcost ( cost )
    routecost
    thisroute @ 
    cells+  ( cost addr1)
    @+ ( cost oldcost addr2)
    >r +
    r> !
;

: addtopath ( from to -- )
    tuck move£
    addcost  ( to)
    addsq 
;


: report ( --)
    .route
    key drop
;

: repeat? ( sq -- flag)
    thisroute count ( sq addr count)
    ?dup if
        1-
        cells over + swap
        do ( sq)
            \        ." repeat? " i  @ . cr
            dup i @ = if drop unloop -1 exit then
        [ 1 cells ] literal +loop
        drop
    else
        2drop
    then
    0
;

: countup ( costtohere costfromhere -- )
    cr
    +
    ." Cost: " dup .

    dup lowcost @
    u< if
        lowcost !
        ." Taking" cr
    else
        drop
        ." Rejecting "
    then
    ." Route: " .route destination @ .xy cr
\    ?break

    [char] . emit
;

\ destination is global
\ cost via square is:
\ thissq=destination -> cost to move
\ else -> cost to move to neighbour with lowest cost
: search ( costsofar thissq -- costfromhere flag)
    dup destination @ = if [char] D emit drop 0 countup 0 cr -1 exit then
    dup cache@ ?dup if  [char] C emit dup . nip tuck  countup cr -1 exit then
    dup repeat? if  [char] R emit 2drop infinite cr 0 exit  then
    over lowcost @ u> if  [char] O emit .route drop . infinite cr 0 exit then
    cr ." In " dup .xy over . cr
    dup addsq -flag
    infinite >r  ( tohere thissq| best)
    swap >r dup>r ( thissq |best tohere thissq )
    neighbours descending  ( N1...Nx x |best tohere thissq)
    begin ( N1...Nx x |best tohere thissq)
        ?dup while 1-
            r@ ." Still in " .xy ." looking at "
            swap ( x-1 nextsq)  dup .xy
            2r@ drop .
            cr
            r@ over move£  ( x-1 nextsq basecost)
            2r@ drop       ( x-1 nextsq basecost tohere)
            over +         ( x-1 nextsq basecost tonext)
            rot            ( x-1 basecost tonext nextsq)
            dup>r          ( x-1 basecost tonext nextsq | best tohere thissq nextsq)
            recurse        ( x-1 basecost fromnext flag)
            recflag
            dup infinite = if 2drop rdrop
                else
                    +      ( x-1 fromhere)
                    r> swap   ( x-1 nextsq fromhere)
                    2r> rot   ( x-1 nextsq tohere thissq fromhere)
                    r>        ( x-1 nextsq tohere thissq fromhere best)
                    2dup u< -if >r drop 2>r drop
                    else
                        drop >r tuck 2>r   ( x-1 nextsq thissq  )
                        ." Best move: " dup .xy ." -> " over .xy cr
                        u.s
                        bestmove swap v!
                    then
                then

    repeat
    2r> r@
    over .xy ." Done" cr
    ( tohere thisq best |best)
    infinite = flag@ 0= or
    if 2drop r>
    else
        r@
        over .xy ." Best cost cached:" dup . cr
        cache!
        drop r>
    then
    flag@
    -1 thisroute +!
;

: reset ( to from -- )
    origin !
    destination !
    
    0 routecost !
    0 thisroute !
    infinite lowcost !
;

2variable startns
2variable endns

: pixelpath  ( to from -- )
    cr ." Starting from " dup .xy ." ( " dup sq@ . ." )" cr
    ." Going to      " over .xy ." ( " over sq@ . ." ) " cr
    reset
    0 origin @ search .
;

\ optimise later
: validedges? ( dest disp -- dest disp flag)
    >r
    dup >xy ( dest x y |r: disp)
    dup r@ - 0< -if  2drop r> -1 exit then   \ North edge valid
    r@ + height < if drop r> -1 exit       then   \ South edge valid
    ( dest x|r: disp)
    dup r@ - 0< -if  drop r> -1 exit then    \ West edge valid
    r@ + width < if  r> -1 exit      then    \ East edge valid
    r> 0  \ no valid edges
;

: donorth ( dest displacement -- )
    ." North" cr
    >r
    dup >xy ( dest x y |r: disp)
    r@ - dup 0< if \ off north side of map
        rdrop 2drop drop
    else ( dest x y2 |r: disp)
        swap   ( dest y2 x |r: disp)
        dup r@ + width 1- min 1+ ( dest y2 x xne|r: disp) \ 1+ for do..loop
        swap r> - 0 max   ( dest y2 xne xnw)
        do ( dest y2)         \ i will be x2
            2dup i swap xy>sq ( dest y2 dest origin)
            pixelpath
        loop
        2drop
    then
;

: dosouth ( dest displacement -- )
    ." South" cr
    >r
    dup >xy ( dest x y |r: disp)
    r@ + dup height < -if \ off south side of map
        rdrop 2drop drop
    else ( dest x y2 |r: disp)
        swap   ( dest y2 x |r: disp)
        dup r@ + width 1- min 1+ ( dest y2 x xne|r: disp) \ 1+ for do..loop
        swap r> - 0 max   ( dest y2 xne xnw)
        do ( dest y2)         \ i will be x2
            2dup i swap xy>sq ( dest y2 dest origin)
            pixelpath
        loop
        2drop
    then
;

: dowest ( dest displacement -- )
    ." West" cr
    >r
    dup >xy ( dest x y |r: disp)
    swap r@ - tuck 0< if \ off west side of map
        rdrop 2drop drop
    else ( dest x2 y |r: disp)
        dup r@ + height 1- min 1+ ( dest x2 y ysw|r: disp) \ 1+ for do..loop
        swap r> - 0 max   ( dest x2 ysw ynw)
        do ( dest x2)    \ i will be y2
            2dup i xy>sq ( dest x2 dest origin)
            pixelpath
        loop
        2drop
    then
;


: doeast ( dest displacement -- )
    ." East" cr
    >r
    dup >xy ( dest x y |r: disp)
    swap r@ + tuck width < -if \ off east side of map
        rdrop 2drop drop
    else ( dest x2 y |r: disp)
        dup r@ + height 1- min 1+ ( dest x2 y ysw|r: disp) \ 1+ for do..loop
        swap r> - 0 max   ( dest x2 ysw ynw)
        do ( dest x2)    \ i will be y2
            2dup i xy>sq ( dest x2 dest origin)
            pixelpath
        loop
        2drop
    then
;


: (fillcache) ( dest)
    -cache  \ make sure it's empty first
    0 ( dest disp)
    begin
        1+         cr ." Displacement " dup . cr
        validedges?  over  24 < and
    while ( dest disp)
            2>r 
            2r@ donorth
            2r@ doeast
            2r@ dosouth
            2r@ dowest
            2r>
    repeat
    2drop
;
    
: fillcache ( dest )
    ns startns 2!
    ['] (fillcache) literal
    10000000 bigrs
    ns endns 2!
    startns 2@
    endns 2@
    ." Time: "  ns- .ns

;


: (trade) ( pop1 pop2 pathdist) dup 100 */ ?dup if */ else 2drop 0 then ;

: trade ( from pop1 to pop2 -- m )
    rot ( f t p2 p1 )
\    2swap rcost ( p2 p1 distance)
    (trade)
;
    

: t 21 32 xy>sq 56 37 xy>sq pixelpath ;
 : t 21 32 xy>sq 52 35  xy>sq pixelpath ;
\ : t 21 32 xy>sq 19 32  xy>sq pixelpath ;
 : t2 21 32 xy>sq dup destination ! fillcache ;

: .from xy>sq cache@ . ;
: best? bestmove swap v@ dup .xy ;

: traceroute ( x y -- )
  xy>sq
  begin
    best? ?dup while repeat
;


\ openmap

4829 constant ossary  \ 3200
2623 constant csio    \ 20000

\ : t ossary csio pixelpath ;

\ ' t 1000000 bigrs

-cache

: t ['] t literal 1000000 bigrs ;

\ openmap 1209 911 pixelpath
\ openmap 510 1209 pixelpath

\ 101 908 area

: .map
  height 0 do
      width 0 do
          i j xy@ . 
      loop
      cr
  loop
;
