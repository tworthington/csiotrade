#! /usr/bin/forth

wordlist: routeapp

forth only
definitions

requires utils

digression lists "lists"

lists last

digression pqueues "pqueue"

pqueues last

requires squares
squares first

digression mapmaking "bmpread"
mapmaking first

routeapp first definitions

variable destination
variable origin

\ Worst case scenario: all squares have 8 possible approaches
mapsquares cells 8 * pqueue: frontier
mapsquares +vector: camefrom
mapsquares +vector: costsofar

mapsquares +vector: tradevol

: .frontier
  frontier size times
  i frontier priority# .
  i frontier item# .xy cr
  iterate
;

sqrts @ 4 / +vector: bestmove

: qdist ( x1 y1 x2 y2 -- distance-squared)
    rot - dup * ( x1 x2 dy²)
    -rot - dup *
    + 2sqrt
;

: todestination ( sq -- distance)
    >xy 
    destination @ >xy qdist
;


: qdist
    rot - dup * ( x1 x2 dy²)
    -rot - dup *
    +
;

\ is sq1 closer to destination than sq2?
: closer? ( sq1 sq2 -- flag)
    >xy rot >xy ( x2 y2 x1 y1)
    destination @ >xy 2dup 2>r
    qdist ( x2 y2 d1²)
    -rot 2r> qdist ( d1² d2²)
    <
;

: closest  ( list l -- list l )
    dup 2 < if exit then
    dup >r \ for returning proper list
    1 do ( list best)
        i pick
        over closer?
        if i roll then
    loop
    r>
;

\ order squares with closest to destination at top
: descending ( list l -- list2 l)
    dup if
        closest
        swap
        >r
        1-
        recurse
        1+ r> swap
    then
;

: best? ( sq1 -- sq2)
  camefrom swap v@
;

: .from xy>sq best? dup .xy >xy ;

: cost ( sq -- cost ) costsofar swap v@ ;

: traceroute ( x y -- )
  xy>sq ." Cost: " costsofar over v@ .
  dup .xy
  begin
    camefrom swap v@
    dup .xy
    dup destination @ =
  until
  drop
;

: heuristic ( next -- penalty)
  >xy destination @ >xy ( x1 y1 x2 y2)
  rot - abs ( x2 x1 dy)
    -rot - abs ( dy dx)
  dup * swap dup * +
  2sqrt 10 2 */
;

: heuristic 0 and ;

: update ( from next cost)
  2dup costsofar rot v!
  2dup ( from next cost next cost)
  over heuristic +
  frontier -val
  drop
  camefrom swap v!
;

[[ pqueues
\ destination is global
\ cost via square is:
\ thissq=destination -> cost to move
\ else -> cost to move to neighbour with lowest cost
: search1 (  -- )
  begin
    frontier empty? not while
      frontier pop drop ( current)
      origin @ over = if drop exit then
      dup>r neighbours descending  ( list l |  current)
      begin
        ?dup
      while
          1-
          swap   ( list-1 l-1 sq_l |current)
          r@ over move£  ( list l next cost | current)
          costsofar r@ v@ +  ( list l next tcost | current)
          over costsofar swap v@  ( list l next tcost csf)
          dup 0=  >r ( list l next tcost csf  |current flg)
          over
          u> r> or if
            r@  ( list l next tcost current)
            -rot
            update
          else
            2drop
          then
      repeat
      rdrop
  repeat
;

: searchAll (  -- )
  begin
    frontier empty? not while
      frontier pop drop ( current)
      dup>r neighbours descending  ( list l |  current)
      begin
        ?dup
      while
          1-
          swap   ( list-1 l-1 sq_l |current)
          r@ over move£  ( list l next cost | current)
          costsofar r@ v@ +  ( list l next tcost | current)
          over costsofar swap v@  ( list l next tcost csf)
          dup 0=  >r ( list l next tcost csf  |current flg)
          over
          u> r> or if
            r@  ( list l next tcost current)
            -rot
            update
          else
            2drop
          then
      repeat
      rdrop
  repeat
;

]]

: reset ( from to -- )
  [[ pqueues
  frontier clear ]]
  destination !
  origin !  
  destination @ 0 frontier -val
  [[ vectors
  camefrom clear
  costsofar clear ]]
;

2variable startns
2variable endns

: pixelpath1  ( from to -- )
  ns startns 2!
  reset
  search1
  ns endns 2!
  startns 2@
  endns 2@
  ." Time: "  ns- .ns cr
;

: pixelpathAll  ( to -- )
  ns startns 2!
  0 swap reset
  searchAll
  ns endns 2!
  startns 2@
  endns 2@
  ." Time: "  ns- .ns cr
;


: (trade) ( pop1 pop2 pathdist) dup 1000 */ ?dup if */ else 2drop 0 then ;
: (trade) ( pop1 pop2 pathdist) */ ;

: trade ( fromx fromy pop1 pop2 -- m )
    2swap xy>sq ( p1 p2 from )
    cost ( p1 p2 distance)
    (trade)
;

: traderoute ( fromx fromy pop1 pop2 -- vol )
  2over xy>sq >r
  trade r> ( vol origin)
  over dup . cr if
    swap >r
    begin
      tradevol over r@ -rot >vi +!
      camefrom swap v@  ( sq | vol)
      dup destination @ =
    until
    tradevol swap r@ -rot >vi +!
    r>
  else
    2drop
    0
  then
;

variable (cities)
: cities ( <name> )  0 (cities) !  create here cell+ , does> @ ;

\ sq pop name namelen
: city ( x y pop caddr len)
  2>r -rot xy>sq , , 2r> swap , ,
  0 , \ trade
  1 (cities) +! ;

: #cities (cities) @ ;

: >city ( i base -- addr) swap 5 cells * + ;

: .city ( i base )
  >city
  @+ swap .xy
  @+ swap ." Population: " .
  @+ @ type
;

( i base -- things)
: >sq >city ;
: >pop >city cell+ ;
: >cityname
  >city
  2 cells+ @+ @ ;
: >trade
  >city 4 cells + ;

\ x y pop name
cities map1cities
57 169  10000 s" Westport" city
84 571    150 s" South Farm" city
136 697 20000 s" Big City" city
147 116   150 s" North Farm" city
147 421    20 s" Portaferry" city
192  40   120 s" Northport" city
312 217  1700 s" Forest Town" city
387 577  2900 s" Iggs" city
433 444   600 s" Three Roads Part" city
701 371   100 s" Spitville"  city
743 220  1100 s" Monkstown" city
872 88    800 s" North Shields" city
901 602  3000 s" Faropolis" city
932 327   800 s" South Shields" city

: named: 0 do i map1cities 2constant loop ;

#cities named: westport southFarm bigCity northFarm portaferry
northport forestTown iggs 3roadspart spitville
monkstown northShields faropolis southShields

\ trade from city
: citytrade ;

: tradereport
  0 ( tot)
  #cities times
    i map1cities >cityname type ."  Trade: " tab
    i map1cities >trade @ 
    dup . ." (" dup i map1cities >pop @ / . ."  per person)" tab ." via: "
    tradevol i map1cities >sq @ v@ dup . ." ("  i map1cities >pop @ / . ."  per person)"
    cr
    + 
  iterate ." Total trade: " .
;

: alltrade
  #cities times
    i if
      i map1cities >sq @ pixelpathAll
      i times
        i j <> if
          i map1cities >sq @ >xy
          i map1cities >pop @ j map1cities >pop @
          ." From " i map1cities >cityname type tab
          ." to " j map1cities >cityname type tab
          traderoute dup i map1cities >trade +! j map1cities >trade +!
        then
      iterate
    then
  iterate
;

: t alltrade ;

: .trade xy>sq tradevol swap v@ . ;

: .map
  height 0 do
      width 0 do
          i j xy@ . 
      loop
      cr
  loop
;

variable scale


: calibrate ( vector -- )
  [[ vectors    
  maximum 2sqrt
  scale !
  ]]
;

: open> ( caddr len -- handle)
    2dup type cr
    drop 438 swap 2 8 linux
    dup 0= throw ;

: process ( vector -- )
    mapsquares 0 do
      dup i v@ dup if  2sqrt 255 scale @ */ 1 max      then
      emit
    loop
    drop
;

: header
    ." P5 "
    width . height . 255 .
;

: startfile ( handle --)
    15 user !
    header
;

: output ( handle vector -- )
    swap
    startfile
    process
;

: close
    15 user @
    1 6 linux throw 
    1 15 user ! ;

: trademap
    alltrade
    tradevol calibrate
    s" test.pgm" open>
    tradevol output
    close
;

: domain ( scale -- )
    mapsquares 0 do
      costsofar i v@ dup if
      over / 
        255 swap - 1 max
      then
       emit
    loop
    drop
;

: domainmap ( city map)
    2dup
    >sq @ pixelpathAll
    s" domain.pgm" open>
    startfile
    >pop @ 2sqrt 1 max domain
    close
;

: t portaferry domainmap ;