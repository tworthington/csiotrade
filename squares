wordlist: squares

digression sq@ "bmpread"

mapmaking first

squares first


definitions

\ ---------------------

variable #terrains
0 #terrains !

20000000 constant infinite

\ a table n x n in size
: xtable ( n <name> -- )
  create dup ,
  dup * cells allot
;

: >= < not ;

: rangechk ( x y addr -- x y addr)
  dup @ ( x y start max )
  >r over r@ >= if abort" Table row out of range" then
  2 pick r> >= if abort" Table column out of range" then ( x y start)
;

: tablexy ( x y addr -- addr2)
  rangechk
  @+ ( x y size start )
  swap >r ( x y start |size)
  rot cells+
  swap r> * cells+
;

\ 4 5 <table> -- val
: xy@ ( x y addr -- addr)
  tablexy @
;

: xy! tablexy ! ;
: xy+! tablexy +! ;

: cfill ( addr cells value -- )
  -rot
  times
    2dup !
    cell+
  iterate
  2drop
;

: default ( n addr -- )
  @+ swap  ( n start size )
  dup * rot cfill
;

: clear ( addr)
  0 swap default
;

: size@ @ ;

: row! ( n y addr -- )
  2dup @ >= if abort" Illegal row store" then
  @+ ( n y size start )
  swap dup>r  ( n y start size |r: size)
  rot * cells+  ( n row^ |r:size)
  r> rot cfill
;

: col! ( n x addr -- )
  2dup @ >= if abort" Illegal col store" then
  @+ swap dup  times  ( n x rowStart size)
      over 2>r           ( n x rowStart |r: size rowStart)
      over cells+  ( n x col^ | size rowStart)
      2 pick      ( n x col^ n| size rowStart)
      swap ! ( n x  |size rowStart)
      r> r@ cells+ r> ( n x nextRowStart size)
  iterate
  4 drops
; 


256 xtable costs

256 cells 2* create terrains$ allot

: t$ ( n -- caddr len) 2* cells terrains$ + 2@ ;

: t$! ( caddr len n -- ) 2* cells terrains$ + 2! ;  

: self! ( n x -- ) dup costs xy! ;
: self@ ( x -- ) dup costs xy@ ;

\ set cost from terrain y to any OTHER to n
: any> ( n y -- )
  dup dup self@ ( n y y c)
  2>r ( n y |r: y c)
  costs col!
  r> r> self!
;

\ set cost of moving to any OTHER terrain from terrain y, to n
: >any ( n y -- )
  dup dup self@ ( n y y c)
  2>r ( n y |r: y c)
  costs row!
  r> r> self!
;

\ set cost of moving from x -> y terrain to n
: cost! ( n x y -- ) costs xy! ;
: cost@ ( x y -- cost ) costs xy@ ;
: cost? cost@ . ;

\ from x to y is average of x->x and y->y
\ from y to x is average of x->x and y->y
: avg ( x y -- )
  2dup dup cost@ swap dup cost@  ( x y ycost xcost)
  + 2/ ( x y average)
  >r   ( x y |r: average)
  2dup r@ -rot cost!
  swap r> -rot cost!
;

10 constant cheapest \ = 60miles per day=30"

: scale:: create , , does> 2@ */ ;

: +terrain ( <name> -- )
  #terrains @ dup 256 = if abort" Too many terrains!" then
  save-input
  constant
  restore-input bl word count #terrains @ t$!
  1 #terrains +!
;

: prev-terrain #terrains @ 1- ;

: " ( n <name> -- ) 10 30 rot */ ( cost <name> )
  +terrain
  prev-terrain ( cost index )
  self!
;

: averages!
  costs size@ ( size start)
  0 do
    costs size@
    0 do
      i j cost@
      cheapest = if  i j avg      then
    loop
  loop
;

cheapest costs default

+terrain impassible
infinite impassible self!
25 " opensea
 9 " city
30 " coastal
 8 " plains
 3 " woods
12 " roads
 6 " ltwoods
 6 " hills
 3 " wdhills
 3 " mts
 1 " swamp
 3 " desert
 2 " scrub
 3 " rough
15 " river
6 " ford
1 " jungle
2 " snow
2 " ice
6 " tundra

averages!

20000 coastal any>
20000 coastal >any

50000 opensea any>
50000 opensea >any

750 river any>
750 river >any

100 river ford cost!
100 ford river cost!

100 city river cost!
100 river city cost!

river coastal avg
river opensea avg

coastal opensea avg

river swamp avg
coastal swamp avg
opensea swamp avg

500 city coastal cost!
500 city opensea cost!

100 coastal city cost!
100 opensea city cost!

60 roads plains cost!

infinite impassible >any
infinite impassible any>

: .costs
  tab tab
  #terrains @ 1 do i t$ type tab loop cr
  #terrains @ 1 do i . i tab t$ type tab
    #terrains @ 1 do
      i j costs xy@ u. tab
    loop
    cr
  loop
  cr
;

.costs

: orthogcost ( from to -- cost)
  sq@ swap sq@ swap
  cost@
;

: diagcost ( from to -- cost) orthogcost 2828427 2000000 */ ;

export{

: moveÂ£ ( from to -- cost)
    2dup - abs  ( from to diff)
    dup 1 = if drop orthogcost
    else width = if orthogcost
        else diagcost
        then then
;


}export

previous definitions
