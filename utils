wordlist: utils

: ]+
  ] lit
  postpone +
; immediate

: ]*
  ] lit
  postpone *
; immediate


: ]# ] lit ; immediate

1 cells constant cell

: $delimit
  char parse   ( caddr len)
;

: digression ( <word> <char>file<char> -- )
  bl word find nip
  $delimit     ( flag caddr len)
  rot if  2drop  else included then
;

: (linerr)
    dup 0 < if dup abs 1000 < if
            throw then then
;

: (allocate) ( size -- addr)
    >r
    0 -1 34 3 r> 0 6 192 linux 
    (linerr)
;

: allocate ( size -- addr)
    dup cell+ (allocate) ( size addr)
    tuck !
;

: mem  ( size <name> -- addr)
    create
    allocate
    ,
  does> @ count
;

: bigrs ( xt size -- ??? )
    rsp@ swap ( xt oldrsp size )
    dup allocate + cell-  ( xt oldrsp newrsp)
    rsp!
    >r
    execute
    r> rsp!
;

: (2constant) ( addr -- a b ) 2@ ;

: 2constant ( a b <name> -- ) create , , does> (2constant) ;

: $@ 2@ ;
: $! ( caddr len addr -- ) tuck ! ! ;

: ," ( <string>" -- )
  [char] " parse ( caddr len)
  align
  dup ,
  here over cell+ allot
  swap zmove
;

: u.s depth times i pick u. iterate ;

16 constant rowlength
: .##  s>d <# # # #> type ;
: .dword s>d <# # # # # # # # # #> type ;

: spaces times space iterate ;

: tab 9 emit ;

: ['] ' ; immediate

: .row ( addr -- )   dup .dword space
 dup rowlength + swap 
 do
   i 4 mod -if space  then 
   i c@ .## space   
  loop ;

\ is n >=l and <=h ?
: limit? ( l n h ) over <  -rot  >  or not ;

: .asciirow ( addr -- ) 
  dup rowlength + swap do  
  33 i c@ 127  limit? if  i c@  else 46 then
  emit loop ;

: dump ( start rows -- )
    base @ >r hex
    rowlength * over + swap do i .row space i .asciirow cr rowlength +loop cr
    u.s cr
    r> base !
; 

: ? dup 2 dump ;

: 2variable
    create 0 , 0 ,
;
    
: under+ ( a b c -- a+c b)
    rot + swap ;

: export{ get-order 2 pick set-current drops ;

: }export definitions ;

: global{ forth-wid set-current ;

: }global definitions ;

\ [[ squares
\ blah blah blah
\ ]]

: [[ ( <wordlist> -- ) ' execute first ; immediate
: ]] previous ; immediate

: dups times dup iterate ;

: diff - abs ;

: ." postpone s" postpone type ; immediate

: ," postpone s" ( caddr cnt)
    dup ,
    here over allot
    swap move
    align
;

: enums: 0 do  i constant  loop ;

\ a must be â‰¤ b
: between? ( n a b -- flag)
    -rot ( b n a )
    over > not ( b n f1)
    -rot
    < not and
;

\ unsigned version
: ubetween? ( n a b -- flag)
    -rot ( b n a )
    over u> not ( b n f1)
    -rot
    u< not and
;

: abort -1 throw ;

: (abort") ( caddr len -- ) type cr -2 throw ;

: abort"
    postpone s"
    state @ if 
        postpone (abort")
    else
        (abort")
    then
; immediate

: ?break
    key 27 = if abort" Break" then
;   

\ nanoseconds
: ns  here 0 2 265 linux throw here 2@ swap ;

: ns- ( ns1 ns2 -- ns)  ( sec1 ns1 sec2 ns2 -- sec3 ns3)
    >r ( sec1 ns1 sec2 )
    rot - ( ns1 sec3)
    r> rot -
;

: us>d ( n -- 0 nl)
    0 swap
;

: .0r ( n w -- )
    swap us>d rot <#
    times
        #
    iterate
    #s
    #> type ;

: .ns ( sec nanosec -- )
    swap 0 .0r [char] . emit
    8 .0r space
;

1 cells constant 1cell
2 cells constant 2cell